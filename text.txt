I made three programs meant to test out parallel processing over tcp over some nodes.
master.c below controls the nodes and reads from them, printing the max number read.
int nodes_conn = 0;
        int listen_socket = server_setup();
        fd_set read_fds;
        fd_set select_fds;
        FD_ZERO(&read_fds);
        int fd_max = 0;
        int socks[nodes];
        int begin = clock();
        while (listen_socket) {
                int client_socket = server_tcp_handshake(listen_socket);
                socks[nodes_conn] = client_socket;
                FD_SET(client_socket, &read_fds);
                if (fd_max < client_socket) fd_max = client_socket;
                nodes_conn++;
                if (nodes_conn == nodes) break;
        }
        printf("All nodes connected.\n");
        int max = INT_MIN;
        int nodes_finished = 0;
        struct timeval timeout;
        timeout.tv_sec = 5;
        timeout.tv_usec = 0;
        while (nodes_finished < nodes) {
                select_fds = read_fds;
                int selret = select(fd_max + 1, &select_fds, NULL, NULL, NULL);
                if (!selret) {
                        printf("sel returned zero\n");
                        return 1;
                }
                for (int i = 0; i < nodes; i++) {
                        if (FD_ISSET(socks[i], &select_fds)) {
                                char buff[128];
                                int n = read(socks[i], buff, sizeof(buff) - 1);
                                if (n > 0) {
                                        buff[n] = '\0';
                                    int curr = atoi(buff);
                                        printf("NEW NUMBER RECIEVED: %d\n", curr);
                                    if (curr > max) max = curr;
                                    close(socks[i]);
                                    FD_CLR(socks[i], &read_fds);
                                    nodes_finished++;
                            } else if (n == 0) {
                            close(socks[i]);
                        FD_CLR(socks[i], &read_fds);
                                        nodes_finished++;
                                }
                        }
                }
        }
        printf("Max is %d, took %f seconds.", max, (double)(clock()-begin)/CLOCKS_PER_SEC);
        return 0;

node.c below runs the compiled program max.c by the segment it was assigned and sends that data to the master
int main(int argc, char *argv[]) {
        char* IP;
        if (argv[1]) IP = argv[1];
        else IP = "127.0.0.1";
    int server_socket = client_tcp_handshake(IP);
    char buff[BUFFER_SIZE];
        memset(buff, 0, BUFFER_SIZE);
        char cmd[2048];
        snprintf(cmd, sizeof(cmd), "%s/progmax %s %s %s 2>&1", argv[2], argv[2], argv[3], argv[4]);
        FILE* fp = popen(cmd, "r");
        printf("Node: Executing command %s\n", cmd);
        if (fgets(buff, sizeof(buff), fp)) {
                printf("Node: Read value '%s' from pipe\n", buff);
                write(server_socket, buff, strlen(buff));
                printf("Node: Sent data to master\n");
        } else printf("empty pipe\n");
        pclose(fp);
        return 0;
}
max.c below finds the max number in the random integer file in the segment it was assigned
#define _FILE_OFFSET_BITS 64
#include <stdio.h>
#include <limits.h>
#include <time.h>
#include <stdlib.h>

int main(int argc, char* argv[]) {
    if (!argv[1]) {
        int begin = clock();
        FILE *file = fopen("random_numbers.txt", "r");
        int max = INT_MIN;
        int curr;
        char buff[64];
        while (fgets(buff, 64, file)) {
            curr = atoi(buff);
            if (max < curr) max = curr;
        }
        fclose(file);
        printf("Max is %d, Took %f sec\n", max, (double)(clock()-begin)/CLOCKS_PER_SEC);
        return 0;
    }

    long long start = atoll(argv[2]);
    long long end = atoll(argv[3]);
        char path[1024];
        snprintf(path, sizeof(path), "%s/random_numbers.txt", argv[1]);
    FILE *file = fopen(path, "r");
    if (!file) return 1;
    fseeko(file, start, SEEK_SET);
    char buff[64];
    if (start != 0) fgets(buff, 64, file);
    int max = INT_MIN;
    int curr;
    while (ftello(file) < end && fgets(buff, 64, file)) {
        curr = atoi(buff);
        if (max < curr) max = curr;
    }
    fclose(file);
    printf("%d\n", max);
        fflush(stdout);
    return 0;
}

When running with 5 nodes, this is the output:
How many nodes should be created? (1-35): 5
All nodes connected.
NEW NUMBER RECIEVED: 2147483611
Node: Executing command
Node: Read value '2147483611
' from pipe
Node: Sent data to master
NEW NUMBER RECIEVED: 2147483612
Node: Executing command
Node: Read value '2147483612
' from pipe
Node: Sent data to master
NEW NUMBER RECIEVED: 2147483612
Node: Executing command
Node: Read value '2147483612
' from pipe
Node: Sent data to master
NEW NUMBER RECIEVED: 2147483614
Node: Executing command
Node: Read value '2147483614
' from pipe
Node: Sent data to master
NEW NUMBER RECIEVED: 2147483647
Max is 2147483647, took 0.001077 seconds.Node: Executing command
Node: Read value '2147483647
' from pipe
Node: Sent data to master

For some reason, this takes more than the expected amount of time, and this output seems wrong. The real output is supposed to be the max number only, but all this printing is for debugging purposes. How do I fix this issue of blocking, and if that doesn't work, is there a different approach to reading the max number over tcp? If you write code, write it most similarly to my style, do not change variables, and do not place comments or empty lines in the code.
